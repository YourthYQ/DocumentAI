from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any

class DocumentInput(BaseModel):
    content: str = Field(..., description="The main text content of the document.")
    metadata: Optional[Dict[str, Any]] = Field(None, description="Optional metadata for the document, e.g., {'source': 'filename.pdf'}")

class DocumentOutput(BaseModel):
    doc_id: str = Field(..., description="The unique identifier for the document.")
    content: str = Field(..., description="The main text content of the document.")
    metadata: Dict[str, Any] = Field(..., description="Metadata associated with the document.")

class DocumentMinimalOutput(BaseModel):
    doc_id: str = Field(..., description="The unique identifier for the document.")
    message: str = Field(default="Document processed successfully.")

class ChatMessageInput(BaseModel):
    session_id: str = Field(..., description="Unique identifier for the conversation session.")
    user_message: str = Field(..., description="The message sent by the user.")

class RetrievedDocInfo(BaseModel):
    doc_id: Optional[str] = Field(None, description="ID of the retrieved document (if available in metadata).")
    score: Optional[float] = Field(None, description="Similarity score of the retrieved document (if available).")
    content: Optional[str] = Field(None, description="The text content of the retrieved document chunk.")
    metadata: Optional[Dict[str, Any]] = Field(None, description="Metadata of the retrieved document.")


class ChatMessageOutput(BaseModel):
    session_id: str = Field(..., description="Unique identifier for the conversation session.")
    user_message: str = Field(..., description="The message sent by the user.")
    ai_response: str = Field(..., description="The response generated by the AI.")
    retrieved_docs: Optional[List[RetrievedDocInfo]] = Field(None, description="List of relevant documents retrieved from the vector store.")

# For health check
class HealthStatus(BaseModel):
    status: str = Field(default="ok")
    mongo_status: str = Field(default="pending")
    redis_status: str = Field(default="pending")
    openai_status: str = Field(default="pending")
    pinecone_status: str = Field(default="pending")
    pinecone_index_status: str = Field(default="pending")


class FileUploadResponse(BaseModel):
    filename: str = Field(..., description="The name of the uploaded file.")
    message: str = Field(..., description="A message indicating the status of the upload and processing.")
    total_chunks_processed: int = Field(..., description="The number of text chunks successfully processed and indexed from the file.")
    document_id: Optional[str] = Field(None, description="A unique identifier assigned to the uploaded document (can be used to group its chunks).")


# --- Chat Log Persistence Models ---
import uuid
from datetime import datetime

class ChatLogEntryModel(BaseModel):
    interaction_id: str = Field(default_factory=lambda: str(uuid.uuid4()), description="Unique identifier for this specific chat interaction (log entry).")
    session_id: str = Field(..., description="Identifier for the chat session this interaction belongs to.")
    user_message: str = Field(..., description="The message sent by the user during this interaction.")
    ai_response: str = Field(..., description="The response generated by the AI for this interaction.")
    timestamp: datetime = Field(default_factory=datetime.utcnow, description="Timestamp of when the interaction was recorded (UTC).")
    retrieved_doc_ids: Optional[List[str]] = Field(None, description="List of document/chunk IDs that were retrieved and used as context to generate the AI response.")
    feedback: Optional[int] = Field(None, description="User-provided feedback for this interaction (e.g., 1 for positive, -1 for negative, 0 for neutral).")
    # Note: Pydantic v2 uses model_dump() instead of dict()
    # model_config = {
    #     "json_encoders": {
    #         datetime: lambda v: v.timestamp() # Example for custom JSON encoding if needed
    #     }
    # }

class SessionDetailModel(BaseModel):
    session_id: str = Field(..., description="Unique identifier for the chat session.")
    last_interaction_time: datetime = Field(..., description="Timestamp of the last interaction in this session (UTC).")
    total_messages: int = Field(..., description="Total number of interactions (user message + AI response pairs) recorded in this session.")
